[{"content":"Command Types As we saw above we have parent and exec types of commands. Users can add more but these are the core ones we support today.\nMost commands are made up of a generic set of options and then have one or more added in addition to specialise them.\nCommon properties reference Most commands include a standard set of fields - those that do not or have special restritions will mention in the docs.\nLets look at how we can produce this command:\nusage: demo say [\u003cflags\u003e] \u003cmessage\u003e Says something using the cowsay command The command called defaults to cowsay but can be configured using the Cowsay configuration item Flags: --help Show context-sensitive help (also try --help-long and --help-man). --cowfile=FILE Use a specific cow file Args: \u003cmessage\u003e The message to displayIt’s made up of a commands member that has these properties:\nname: example description: Example application version: 1.0.0 author: Operations team \u003cops@example.net\u003e help_template: default # optional  commands:  -  # The name in the command: 'example say ....' (required)  name: say   # Help showng in output of 'example help say' or 'example say --help` (required)  description: |Says something using the cowsay command The command called defaults to cowsay but can be configured using the Cowsay configuration item   # Selects the kind of command, see below (required)  type: exec # or any other known type   # Optionally you can run 'example say hello' or 'example s hello' (optional)  aliases:  - s    # Arguments to accept (optional)  arguments:  - name: message  description: The message to display  required: true   # Flags to accept (optional)  flags:  - name: cowfile  description: Use a specific cow file  placeholder: FILE   # Sub commands to create below this one (optional, but see specific references)  commands: []Here we show the initial options that define the application followed by commands. All the top settings are required except help_template, it’s value may be one of compact, long, short or default. When not set it will equal default. Experiment with these options to see which help format suits your app best (requires version 0.0.9).\nSince version 0.0.6 you can emit a banner before invoking the commands in an exec, use this to show a warning or extra information to users before running a command. Perhaps to warn them that a config override is in use like here:\n - name: say  description: Say something using the configured command  type: exec  command: | {{ default .Config.Cowsay \"cowsay\" }} {{ .Arguments.message | escape }}  banner: |{{- if (default .Config.Cowsay \"\") -}} \u003e\u003e \u003e\u003e Using the {{ .Config.Cowsay }} command \u003e\u003e {{- end -}}  arguments:  - name: message  description: The message to send to the terminal  required: trueSince version 0.0.7 we support Cheat Sheet style help, see the dedicated guide about that.\nArguments An argument is a positional input to a command. example say hello, when the command is say the hello would be the first argument.\nArguments can have many options, the table below detail them and the version that added them.\n   Option Description Required Version     name A unique name for each flag yes    description A description for this flag, typically 1 line yes    required Indicates that a value for this flag must be set, which includes being set from default     enum An array of valid values, if set the flag must be one of these values  0.0.4   default Sets a default value when not passed, will satisfy enums and required. For bools must be true or false  0.0.4    Flags A flag is a option passed to the application using something like --flag, typically these are used for optional inputs. Flags can have many options, the table below detail them and the version that added them.\n   Option Description Required Version     name A unique name for each flag yes    description A description for this flag, typically 1 line yes    required Indicates that a value for this flag must be set, which includes being set from default     placeholder Will show this text in the help output like --cowfile=FILE     enum An array of valid values, if set the flag must be one of these values  0.0.4   default Sets a default value when not passed, will satisfy enums and required. For bools must be true or false  0.0.4   bool Indicates that the flag is a boolean (see below)  0.1.1   env Will load the value from an environment variable if set, passing the flag specifically wins, then the env, then default  0.1.2   short A single character that can be used instead of the name to access this flag. ie. --cowfile might also be -F  0.1.2    Boolean Flags We support boolean flags since version 0.1.1:\n - name: delete  description: Delete the data  type: exec  command: |{{if .Flags.force}} rm -rfv /nonexisting {{else}} echo \"Please pass --force to delete the data\" {{end}}  flags:  - name: force  description: Required to pass when removing data  bool: trueHere we have a --force flag that is used to influence the command. Booleans can have their default set to true or \"true\" which will then add a --no-flag-name option added to negate it.\nConfirmations You can prompt for confirmation from a user for performing an action:\n - name: delete  description: Delete the data  type: exec  confirm_prompt: \"Really?\"  command: rm -rf /nonexistingBefore running the command the user will be prompted to confirm he wish to do it. Since version 0.2.0 an option will be added to the CLI allowing you to skip the prompt using --no-prompt.\n","description":"","tags":null,"title":"Common Settings","uri":"/reference/common-settings/index.html"},{"content":"Installation Over on our Releases page you will find binaries, rpms, debs, zip files and more holding the appbuilder command. There is just one command and you can place it anywhere in your path.\nIf your editor supports it there is a JSON Schema for the definition.\nWe publish OS X and Linux homebrew packages:\nbrew tap choria-io/tap brew install choria-io/tap/appbuilderHello World We will make a little command that invokes cowsay to demonstrate some of the capabilities of the system.\nWe want to be able to run this command and it should invoke cowsay, cowthink or if configured to do so use animalsay instead of cowsay\ndemo say \"hello world\" demo think \"hello world\"First we have to write a YAML file (demo-app.yaml) that describes our demo application, we have reference sections in the wiki for all the options, so this being an introduction, will be short on details.\nname: demo description: Demo application for Choria App Builder author: https://github.com/choria-io/appbuilder commands: - name: say description: Say something using the configured command type: exec command: | {{ default .Config.Cowsay \"cowsay\" }} {{ .Arguments.message | escape }} arguments: - name: message description: The message to send to the terminal required: true - name: think description: Think something using a cow type: exec command: | cowthink {{ .Arguments.message | escape }} arguments: - name: message description: The message to send to the terminal required: truePlace this file in either /etc/appbuilder/demo-app.yaml or ~/.config/appbuilder/demo-app.yaml (~/Library/Application Support/appbuilder/demo-app.yaml on a Mac).\n$ sudo mkdir -p /etc/appbuilder $ sudo cp demo-app.yaml /etc/appbuilder/ $ sudo ln -s /usr/local/bin/appbuilder /usr/bin/demo $ demo say \"hello world\" _____________ \u003c hello world \u003e ------------- \\ ^__^ \\ (oo)\\_______ (__)\\ )\\/\\ ||----w | || || $ demo think \"this is pretty cool\" _____________________ ( this is pretty cool ) --------------------- o ^__^ o (oo)\\_______ (__)\\ )\\/\\ ||----w | || ||Finally, if you read the YAML file, you may see we made the system configurable, lets look how that works.\nCreate the following in /etc/appbuilder/demo-cfg.yaml\nCowsay: animalsayNow when we invoke demo say it will use animalsay:\n$ demo say \"hello world\" _____________ \u003c hello world \u003e ------------- \\ ____________ \\ |__________| / /\\ / / \\ /___________/___/| | | | | ==\\ /== | | | O O | \\ \\ | | \u003c | \\ \\| /| | \\ \\ / | \\_____/ | / / / /| | / /| /||\\| | /||\\/ -------------| | | | | \u003c__/ \\__\u003e","description":"","tags":null,"title":"Quick Start","uri":"/quick-start/index.html"},{"content":"A parent is a placeholder, you can have a command like example deploy status and example deploy upgrade, here the deploy is a parent. It’s just there to group related commands and takes no action on it’s own.\nIt requires the the name, description, type and commands and the optional aliases.\nIt does not accept flags, arguments or confirm_prompt.\nname: deploy description: Manage deployment of the system type: parent  # Commands are required for the parent type and should have more than 1 commands: []","description":"","tags":null,"title":"Parent Command Type","uri":"/reference/parent/index.html"},{"content":"Command Components The system primarily is there to execute a type of command somewhere in the hierarchy of a CLI tools sub commands.\nLets say we have an app called demo that has commands demo say and demo think the say and think bits are commands. In this example these are commands of type exec - they run a shell command.\nIf we had a command demo deploy status and demo deploy upgrade then generally the deploy would not perform any action, it’s there mainly to achor sub commands and show help information. Here the deploy command would be of type parent.\nGenerally I would suggest nested commands are structured as root -\u003e parent -\u003e parent -\u003e exec and never root -\u003e parent -\u003e exec -\u003e exec. If you do decide to do that I strongly suggest the first exec is a read only action like showing some status. User should feel safe to execute parents without unintended side effects.\nFlags and Arguments Often we need to pass some parameters to commands, for example if we have one to upgrade some software it might be demo upgrade 1.2.3. Here the 1.2.3 is an argument, you can have a number of arguments and they can be set to be required or optional. If you have multiple arguments an optional one can not be before a required one.\nFlags are generally kept for optional items like demo upgrade 1.2.3 --channel=nightly, here we pass a flag --channel. At present we only support flags with string values. We intend to support enums of valid values and boolean flags.\n","description":"","tags":null,"title":"Reference","uri":"/reference/index.html"},{"content":"Use the exec command to execute commands found in your shell, and, optionally format their output through JQ.\nThe exec command supports data transformations.\nRunning commands An exec runs a command, it is identical to the generic example shown earlier and accepts flags, arguments and sub commands. The only difference is that it adds a command, environment (since 0.0.3) and transform (since 0.0.5) items.\nBelow the example that runs cowsay integrated with configuration:\nname: say description: Says something using the cowsay command type: exec  dir: /tmp  environment:  - \"MESSAGE={{ .Arguments.message}}\"  command: | {{ default .Config.Cowsay \"cowsay\" }} \"{{ .Arguments.message | escape }}\"  arguments:  - name: message  description: The message to display  required: trueThe command is how the shell command is specified and we show some templating. This will read the .Config hash for a value Cowsay if it does not exist it will default to \"cowsay\". We also see how we can reference the .Arguments to access the value supplied by the user, we escape it for shell safety.\nWe also show how to set environment variables using environment, this too will be templated.\nSince version 0.9.0 setting dir will execute the command in that directory. This setting supports templating and has an sets extra variables UserWorkingDir for the directory the user is in before running the command, AppDir and TaskDir indicating the directory the definition is in.\nSetting environment variable BUILDER_DRY_RUN to any value will enable debug logging, log the command and terminate without calling your command.\nShell scripts A shell script can be added directly to your app, setting shell will use that command to run the script, if not set it will use $SHELL, /bin/bash or /bin/sh which ever is found first.\nThe script is parsed through templating.\nname: script description: A shell script type: exec shell: /bin/zsh script: |for i in {1..5} do echo \"hello world\" done Common helper functions We provide a basic helper shell script that can be used to echo text to the screen in various ways. To use this you can source the script:\n Version Hint Added in version 0.6.3\n  name: script description: A shell script type: exec shell: /bin/zsh script: |set -e . \"{{ BashHelperPath }}\" ab_announce Hello World This will output:\n\u003e\u003e\u003e Hello WorldIt provides a few functions:\n ab_say prefix the message using a single prefix \u003e\u003e\u003e ab_announce prefix the message with \u003e\u003e\u003e with a line of \u003e\u003e\u003e before and after the message ab_error prefix the message with !!! ab_panic prefix the message with !!! and exit the script with code 1  The \u003e\u003e\u003e can be configured by setting AB_SAY_PREFIX and the !!! by setting AB_ERROR_PREFIX after sourcing the helper.\nThe output can have time stamps added to the lines by setting AB_HELPER_TIME_STAMP shell variable to T for time and D for time and date prefixes.\nRetrying failed executions Failing executions can be tried based on a backoff policy, here we configure a maximum of 10 attempts with varying sleep times that would include randomized jitter.\nScripts can detect if they are running in a retry by inspecting the BUILDER_TRY environment variable.\nname: retry description: A shell script execution with backoff retries type: exec command: ./script.sh backoff:  # Maximum amount of retries, required  max_attempts: 10  # Maximum sleep time + jitter, optional  max_sleep: 20s  # Minimum sleep time + jitter, optional  min_sleep: 1s  # Number of steps in the backoff policy, once the max is reached  # further retries will jitter around max_sleep, optional  steps: 5Only the max_attempts setting is required, min_sleep defaults to 500ms and max_sleep defaults to 20s with steps defaulting to max_attempts.\n","description":"","tags":null,"title":"Exec Command Type","uri":"/reference/exec/index.html"},{"content":"Some features are ongoing experiments and not part of the supported feature set, this section will call them out.\nLocal Task Mode While it’s nice to have a formal machine-wide command that behaves like a normal Unix CLI command I found I would like to use this same framework to build project specific helpers.\n Version Hint This is available since version 0.6.2 and GA since 0.9.0.\n  Imagine you have a development project and have utility commands to update dependencies, serve the documentation in preview mode, run tests or build custom binaries. This is a lot of different commands and tools to learn, wouldn’t it be nice if there was a single command you can run in any of your projects to get a project specific custom app?\n$ abt usage: abt [\u003cflags\u003e] \u003ccommand\u003e [\u003cargs\u003e ...] App Builder Task Help: https://choria-io.github.io/appbuilder Commands: help [\u003ccommand\u003e...] dependencies update [\u003cflags\u003e] test [\u003cdir\u003e] docs serve [\u003cflags\u003e] build binary [\u003cflags\u003e] snapshotHere I run abt in this project directory, if I ran it elsewhere or in my home directory I would get a different command.\nThis isn’t targeting general build pipelines but rather a way to make per project/directory utilities.\nThe full capabilities of the core App Builder definitions are available, the only thing that really change is how definitions and configurations are found.\nApp Definition Locations The abt command will search from the current directory upward until it finds one of these files:\n ABTaskFile.dist.yaml ABTaskFile.dist.yml ABTaskFile.yaml ABTaskFile.yml ABTaskFile  In this manner a project can ship a default task file and users can provide local overrides.\nIt’s common that a task file will want to run something in a known directory relative to its location, to facilitate this the exec command has some new template behaviors that can be used with the new dir property to achieve this regardless of the working directory the user is in.\n {{ UserWorkingDir }} - the directory the user ran the command in {{ AppDir }} or {{ TaskDir }} - the directory the task file is located in  An example can be found in the source repository for this project.\nConfiguration Configuration is looked for in the local directory in the .abtenv file. At present this is not searched for in parent directories.\n","description":"","tags":null,"title":"Local Task Mode","uri":"/tasks/index.html"},{"content":"Use the scaffold command to create directories of files based on templates.\nThe Sprig functions library is available to use in templates.\n Version Hint This was added in version 0.7.0\n  Scaffolding files First we will just show the most basic example:\nname: scaffold description: Demonstrate scaffold features by creating some go files type: scaffold arguments:  - name: target  description: The target to create the files in  required: true  target: \"{{ .Arguments.target }}\" source:  \"main.go\": |// Copyright {{ .Arguments.author }} {{ now | date \"2006\" }} package main import \"{{ .Arguments.package }}/cmd\" func main() {cmd.Run()} This generates a file main.go in the directory set using the target argument. The target directory must not exist.\nComplex trees can be created like this:\nsource:  \"cmd\":  \"cmd.go\": | // content not shown  \"main.go\": | // content not shownHere we will have a directory cmd with cmd/cmd.go inside along with top level main.go.\nStoring files externally In the example we have the template embedded in the YAML file, its functional but does not really scale well.\nYou can create a directory full of template files that mirror the target directory layer do this instead:\nname: scaffold description: Demonstrate scaffold features by creating some go files type: scaffold arguments:  - name: target  description: The target to create the files in  required: true flags:  - name: template  description: The template to use  default: golang  target: \"{{ .Arguments.target }}\" source_directory: /usr/local/templates/{{ .Flags.template }}Now we will use /usr/local/template/golang by default and whatever is passed in --template instead of golang otherwise.\nPost processing files In the first example we showed a poorly formatted go file, the result will be equally badly formatted.\nHere we show how to post process the files using gofmt:\nname: scaffold description: Demonstrate scaffold features by creating some go files type: scaffold arguments:  - name: target  description: The target to create the files in  required: true  target: \"{{ .Arguments.target }}\" source_directory: /usr/local/templates/default  post:  - \"*.go\": \"gofmt -w\"  - \"*.go\": \"goimports -w '{}'\"The new post structure defines a list of processors based on a file pattern match done using filepath.Match.\nAs shown the same pattern can be matched multiple times to run multiple commands on the file.\nIf the string {} is in the file it will be replaced with the full path to the file otherwise the path is set as last argument. When using this format it’s suggested you use quotes like in the example.\nConditional rendering By default all files are rendered even when the result is empty, by setting skip_empty: true any file that results in empty content will be skipped.\nname: scaffold description: Demonstrate scaffold features by creating some go files type: scaffold arguments: - name: target  description: The target to create the files in  required: true flags: - name: gitignore  description: Create a .gitignore file  bool: true  default: true  target: \"{{ .Arguments.target }}\" source_directory: /usr/local/templates/default skip_empty: trueWe can now create a template for the .gitignore file like this:\n{{ if .Flags.gitignore }} # content here {{ end }}This will result in a file that is empty - or rather just white space in this case - this file will be ignored and not written to disk.\nRendering partials We support partials that can be reused, any files in the _partials directory will be skipped for normal processing, you can reference these files from other files:\n Version Hint This was added in version 0.7.4\n  {{ render \"_partials/go_copyright\" . }} package main func main() { }If you now made a file _partials/go_copyright in your source templates holding the following:\n// Copyright {{ .Arguments.author }} {{ now | date \"2006\" }}You can easily reuse the content of the Copyright strings and update all in one place later.\nRendering files from templates It’s often the case that you need to create new files that is not in the actual template source. Perhaps you ask a user how many of a certain thing they need and then you need to create that many files. This means you will likely have a Partial that can be used to make the file and need to invoke it many times.\n Version Hint This was added in version 0.7.4\n  To use this you can store a template in the _partials directory and then render files like this:\n{{- $flags := .Flags }} {{- range $cluster := $flags.Clusters | atoi | seq | split \" \" }} {{- $config := cat \"cluster-\" $cluster \".conf\" | nospace }} {{- render \"_partials/cluster.conf\" $flags | write $config }} {{- end }}This will render and, using the write helper, save cluster-{1,2,3,...}.conf for how many ever clusters you had in Flags. The file will be post processed as normal and written relative to the target directory.\nWe save .Flags in $flags because within the range the . will not point to the top anymore, so this ensures we can access the passed in flags in the _partials/cluster.conf template.\nIf you place this loop in a file that is only there to generate these other files then the resulting empty file can be ignored using skip_empty: true in the scaffold definition.\nCustom template delimiter When generating Go projects you might find you want to place template tags into the final project, for example when generating a ABTaskFile.\nWith the final ABTaskFile having the same template delimiters will cause havoc.\nYou can change the delimiters of the template source to avoid this:\nname: scaffold description: Demonstrate scaffold features by creating some go files type: scaffold arguments: - name: target  description: The target to create the files in  required: true  target: \"{{ .Arguments.target }}\" source_directory: /usr/local/templates/default skip_empty: true left_delimiter: \"[[\" right_delimiter: \"]]\"Our earlier .gitignore would now be:\n[[ if .Flags.gitignore ]] # content here {{ these will not be changed }} [[ end ]]","description":"","tags":null,"title":"Scaffold Command Type","uri":"/reference/scaffold/index.html"},{"content":"The Discover command interact with the Choria Discovery system used to find fleet nodes based on a vast array of possible queries and data sources.\nSince this is built into Choria it will simply use your Choria Client configuration for the user executing the command to find the Choria Brokers and more. It supports the usual override methods such as creating a choria.conf file in your project working directory. No connection properties are required or supported.\nBefore using this command type I suggest reading about the Choria Discovery System.\n Version Hint This feature is only available when hosting App Builder applications within the Choria Server version 0.26.0 or newer\n  Overview This command supports all the standard properties like Arguments, Flags, Banners and more, below is a simply command that finds apache servers.\nname: find description: Finds all machines tagged as Apache Servers type: discover  std_filters: true filter:  classes:  - roles::apacheWhen run it will show a list of matching nodes, one per line. It also accepts the --json flag to enable returning a JSON array of matching nodes.\nSince the std_filters option is set the command will also accept additional filters in standard Choria format. Flags like -C, -F, discovery mode selectors and more. User supplied options will be merged/appended with the ones supplied in the YAML file. By default, none of the standard Choria flags will be added to the CLI.\nAll the filter values, even arrays and objects, support templating.\nFilter Reference The main tunable here is the filter, below a reference of available options. The examples here are a bit short, I suggest you read the Choria Discovery Documentation for a thorough understanding.\n   Key Description Example     collective The collective to target, defaults to main collective collective: development   facts List of fact filters as passed to -F facts: [\"country=uk\"]   agents List of agent filters as passed to -A agents: [\"puppet\"]   classes List of Config Management classes to match as passed to -C classes: [\"apache\"]   identities List of node identities to match as passed to -I identities:[\"/^web/\"]   combined List of Combined filters as passed to -W combined:[\"/^web/\",\"location=uk\"]   compound A single Compound filter as passed to -S compound: \"with('apache') or with('nginx')   discovery_method A discovery method to use like inventory as passed to --dm discovery_method:\"flatfile\"   discovery_options A set of discovery options, specific to the discovery_method chosen discovery_options: {\"file\":\"/etc/inventory.yaml\"}   discovery_timeout How long discovery can run, in seconds, as passed to --discovery-timeout discovery_timeout: 2   dynamic_discovery_timeout Enables windowed dynamic timeout rather than a set discovery timeout dynamic_discovery_timeout: true   nodes_file Short cut to use flatfile discovery with a specific file, as passed to --nodes nodes_file: /etc/fleet.txt    ","description":"","tags":null,"title":"Discover Command Type","uri":"/reference/discovery/index.html"},{"content":"Some features are ongoing experiments and not part of the supported feature set, this section will call them out.\nForm based data generation wizards The general flow of applications is to expose Arguments and Flags when then can be used in templates to create files or render some output. This works quite well but can be limiting for more complex needs.\nSo we are introducing a full wizard style question-and-answer system that let you guide users through help, questions, validations and more to construct complex data. The generated data supports almost everything JSON supports and can be deeply nested.\nThe general use case is to guide users through creating complex configuration files.\n Version Hint This was added in version 0.9.0\n  It supports skipping sections of questions based on previous answers and generally tries to be a fully generic tool for getting data from users.\nThe gathered data can be sent to transforms for scaffolding or templating into a final form.\ncommands:  - name: configuration  type: form  properties:  - name: listen  description: The network address to listen on  required: true  default: 127.0.0.1:-1  help: Examples include localhost:4222, 192.168.1.1:4222 or 127.0.0.1:4222  - name: accounts  description: Local accounts  help: Sets up a local account for user access.  type: object  empty: absent  properties:  - name: users  description: Users to add to the account  required: true  type: array  properties:  - name: user  description: The username to connect as  required: true  - name: password  description: The password to connect with  type: password  required: trueWhen run this looks a bit like this, with no transform the final data is just dumped to STDOUT:\n$ abt form Demonstrates use of the form based data generator ? Press enter to start The network address and port to listen on ? listen 127.0.0.1:-1 Multiple accounts ? Add accounts entry Yes ? Unique name for this entry USERS The username to connect as ? user user1 The password to connect with ? password ****** ? Add additional 'users' entry No ? Add accounts entry Yes ? Unique name for this entry SYSTEM The username to connect as ? user system The password to connect with ? password ****** ? Add additional 'users' entry No ? Add accounts entry No { \"SYSTEM\": { \"users\": [ { \"password\": \"secret\", \"user\": \"system\" } ] }, \"USERS\": { \"users\": [ { \"password\": \"secret\", \"user\": \"user1\" } ] }, \"listen\": \"127.0.0.1:-1\" } The form command is a generic command with the only addition being an array of making up the questions properties, these are defined as below:\n   Property Description     name Unique name for each property, in objects this would be the name of the key in the object   description Information shown to the user before asking the questions   help Help shown when the user enters ? in the prompt   empty What data to create when no values are given, one of array, object, absent   type The type of data to gather, one of string, integer, float, bool, password, object or array. Objects and Arrays will nest   conditional An expr expression that looks back at the already-entered data and can be used to skip certain questions   validation A validation expression that will validate user input and ask the user to enter the value again on fail   required A value that is required cannot be skipped   default Default value to set   enum Will only allow one of these values to be set, presented as a select list   properties Nested questions to ask, array of properties as described in this table    A full example can be seen in the example directory of the project.\nValidation uses the validators shown in the next section - Argument and Flag Validations with value being the data just-entered by the user.\nConditional queries are also handled using expr, the example below looks back at the accounts entry (see example above) and will only ask this thing when the user opted to add accounts:\n - name: thing  description: Adds a thing if accounts are set  empty: absent  conditional: Input.accounts != nilArgument and Flag Validations One might need to ensure that the input provided by a user passes some validation, for example when passing commands to shell scripts one has to be careful about Shell Injection.\nWe support custom validators on Arguments and Flags using the Expr Language\n Version Hint This is available since version 0.8.0.\n  Based on the Getting Started example that calls cowsay we might wish to limit the length of the message to what would work well with cowsay and also ensure there is no shell escaping happening.\narguments:  - name: message  description: The message to display  required: true  validate: len(value) \u003c 20 \u0026\u0026 is_shellsafe(value)We support the standard expr language grammar - that has a large number of functions that can assist the validation needs - we then add a few extra functions that makes sense for operation teams.\nIn each case accessing value would be the value passed from the user\n   Function Description     isIP(value) Checks if value is an IPv4 or IPv6 address   isIPv4(value) Checks if value is an IPv4 address   isIPv6(value) Checks if value is an IPv6 address   isInt(value) Checks if value is an Integer   isFloat(value) Checks if value is a Float   isShellSafe(value) Checks if value is attempting to to do shell escape attacks    Compiled Applications It’s nice that you do not need to compile App Builder apps into binaries as it allows for fast iteration, but sometimes it might be desired.\nAs of version 0.7.2 we support compiling binaries that contain an application.\nGiven an application in app.yaml we can create a small go stub:\npackage main  import ( \t\"context\" \t_ \"embed\" \t\"os\"  \t\"github.com/choria-io/appbuilder/builder\" \t\"github.com/choria-io/fisk\" )  //go:embed app.yaml var def []byte  func main() { \tbuilder.MustRegisterStandardCommands()  \tcmd := fisk.Newf(\"myapp\", \"My compiled App Builder application\")  \terr := builder.MountAsCommand(context.TODO(), cmd, def, nil) \tif err != nil { \tpanic(err) \t}  \tcmd.MustParseWithUsage(os.Args[1:]) }When you compile this as a normal Go application your binary will be an executable version of the app.\nHere we mount the application at the top level of the myapp binary, but you could also mount it later on - perhaps you have other compiled in behaviors you wish to surface:\nfunc main() { \tbuilder.MustRegisterStandardCommands()  \tcmd := fisk.Newf(\"myapp\", \"My compiled App Builder application\") \tembedded := cmd.Command(\"embedded\",\"Embedded application goes here\")  \terr := builder.MountAsCommand(context.TODO(), embedded, def, nil) \tif err != nil { \tpanic(err) \t}  \tcmd.MustParseWithUsage(os.Args[1:]) }Here we would end up with myapp embedded [app commands] - the command being mounted at a deeper level in the resulting compiled application. This way you can plug a App Builder command into any level programmatically.\n","description":"","tags":null,"title":"Experiments","uri":"/experiments/index.html"},{"content":"The RPC command interact with the Choria RPC system used execute actions on remote nodes.\nSince this is built into Choria it will simply use your Choria Client configuration for the user executing the command to find the Choria Brokers and more. It supports the usual override methods such as creating a choria.conf file in your project working directory. No connection properties are required or supported.\nBefore using this command type I suggest reading about Choria Concepts.\nThe rpc command supports data transformations.\n Version Hint This feature is only available when hosting App Builder applications within the Choria Server version 0.26.0 or newer\n  Overview This command supports all the standard properties like Arguments, Flags, Banners and more, it also incorporates the discovery features of the Discover Command Type in order to address nodes.\nBelow a simple RPC request.\nname: stop description: Stops the Service gracefully type: rpc  request:  agent: service  action: stop  inputs:  service: httpdThis will look and behave exactly like choria req service stop service=httpd.\nAdjusting CLI Behavior A number of settings exist to adjust the behavior or add flags to the CLI at runtime. Generally you can either allow users to supply values sugh as --json, or force the output to be JSON but you cannot allow both at present:\n   Setting Description     std_filters Enables standard filter flags like -C, -W and more   output_format Forces a specific output format, one of senders, json or table   output_format_flags Enables --senders, --json and --table options, cannot be set with output_format   display Supplies a setting to the typical --display option, one of ok, failed, all or none   display_flag Enables the --display flag on the CLI, cannot be used with display   batch_flags Adds the --batch and --batch-sleep flags   batch, batch_sleep Supplies values for --batch and --batch-sleep, cannot be used with batch_flags   no_progress Disables the progress bar`   all_nodes_confirm_prompt A confirmation prompt shown when an empty filter is used    Request Parameters Every RPC request needs request specified that must have at least agent and action set.\nInputs are allowed as a string hash - equivalent to how one would type inputs on the choria req CLI.\nIt also accepts a filter option that is the same as that in the discover command.\nname: stop description: Stops the Service gracefully type: rpc  request:  agent: service  action: stop  inputs:  service: httpd  filter:  classes:  - roles::apacheFiltering Replies Results can be filtered using a result filter, this allows you to exclude/include specific replies before rendering the results.\nHere’s an example that will find all Choria Servers with a few flags to match versions, it invokes the rpcutil#daemon_states action and then filters results matching a query. Only the matching node names are shown.\nname: busy description: Find Choria Agents matching certain versions type: rpc  # list only the names output_format: senders  flags:  - name: ne  description: Finds nodes with version not equal to the given  placeholder: VERSION  reply_filter: ok() \u0026\u0026 semver(data(\"version\", \"!= {{.Flags.ne}}\"))  - name: eq  description: Finds nodes with version equal to the given  placeholder: VERSION  reply_filter: ok() \u0026\u0026 semver(data(\"version\", \"== {{.Flags.eq}}\"))  request:  agent: rpcutil  action: daemon_statsTransforming Results Results can be transformed data transformations, here’s an example that gets the state of a particular autonomous agent:\nname: state description: Obtain the state of the service operator type: rpc transform:  query: | .replies | .[] | select(.statuscode==0) | .sender + \": \" + .data.state request:  agent: choria_util  action: machine_state  inputs:  name: natsWhen run it will just show lines like:\nn1-lon: RUN n3-lon: RUN n2-lon: RUN","description":"","tags":null,"title":"Choria RPC Command Type","uri":"/reference/rpc/index.html"},{"content":"The KV command interact with the Choria Key-Value Store and supports usual operations such as Get, Put, Delete and more.\nSince this is built into Choria it will simply use your Choria Client configuration for the user executing the command to find the Choria Brokers and more. It supports the usual override methods such as creating a choria.conf file in your project working directory. No connection properties are required or supported.\n Version Hint This feature is only available when hosting App Builder applications within the Choria Server version 0.26.0 or newer\n  Overview All variations of this command have a number of required properties, here’s the basic get operation, all these keys are required:\nname: version description: Retrieve the `version` key type: kv  action: get bucket: DEPLOYMENT key: versionUsual standard properties like flags, arguments, commands and so forth are all supported. The bucket and key flags supports templating.\nWriting data using put Data can be written to the bucket, it’s identical to the above example with the addition of the value property that supports templating.\nname: version description: Stores a new version for the deployment type: kv  action: put bucket: DEPLOYMENT key: version value: '{{- .Arguments.version -}}' arguments:  - name: version  description: The version to store  required: trueRetrieving data and transformations using get Stored data can be retrieved and rendered to the screen, typically the value is just dumped. Keys and Values however have additional metadata that can be rendered in JSON format.\nname: version description: Retrieve the `version` key type: kv  action: get bucket: DEPLOYMENT key: state  # Triggers rendering the KV entry as JSON that will include metadata ab out the value. json: trueFurther if it’s known that the entry holds JSON data it can be formatted using data transformations:\nname: version description: Retrieve the `version` key type: kv  action: get bucket: DEPLOYMENT key: state  transform:  query: .stateDeleting data using del Deleting a specific key is very similar to a basic retrieve, just use a different action:\nname: version description: Deletes the deployment configuration property type: kv  action: del bucket: DEPLOYMENT key: configurationViewing key history using history Choria Key-Value store optionally has historical data for keys, the data can be shown in tabular (default) or JSON formats:\nname: version description: Deploy version history type: kv  action: history bucket: DEPLOYMENT key: version  # optionally renders the result as JSON json: true","description":"","tags":null,"title":"KV Command Type","uri":"/reference/kv/index.html"},{"content":"Templates allow you to interpolate values from Flags, Arguments and Configuration into some aspects of commands.\nFor example the exec command type allows you to use templates to put arguments into the command being run.\nWe use the Go template language at the moment, it’s not the best we might look at something else later.\nOnly some fields are parsed through templates, the documentation for each command type will call out what is supported.\nReference An example template use was shown in the exec documentation:\ncommand: | {{ default .Config.Cowsay \"cowsay\" }} \"{{ .Arguments.message | escape }}\"Here we have examples of accessing the .Config and .Arguments structures and using some functions.\nAvailable Data    Key Description     .Config Data stored in the configuration file for this application   .Arguments Data supplied by users using command arguments   .Flags Data supplied by users using command flags    Available Functions    Function Description Example     require Asserts that some data is available, errors with an optional custom message on failure {{ require .Config.Password \"Password not set in the configuration\" }}   escape Escapes a string for use in shell arguments {{ escape .Arguments.message }}   read_file Reads a file {{ read_file .Arguments.file }}   default Checks a value, if its not supplied uses a default {{ default .Config.Cowsay \"cowsay\" }}    ","description":"","tags":null,"title":"Templating","uri":"/reference/templating/index.html"},{"content":"Transformations is like a shell pipe defined in App Builder. We have a number of transformations and using them is entirely optional - often a shell pipe would be much better.\nThe reason for adding transformations like jq to App Builder itself is to have it function in places where that 3rd party dependency is not met. Rather than require everyone to install JQ - and handle that dependency, we just add a JQ dialect directly to App Builder.\nA basic example of transformations can be seen here:\nname: ghd description: Gets the description of a Github Repo type: exec command: | curl -s -H \"Accept: application/vnd.github.v3+json\" https://api.github.com/repos/choria-io/appbuilder  transform:  jq:  query: .descriptionHere we call out a REST API that returns JSON payload using curl and then extract the description field from the result using a JQ transform\n$ demo ghd Tool to create friendly wrapping command lines over operations toolsNot every command supports transforms, so the individual command documentation will call out it out.\nJQ Transform The jq transform uses a dialect of JQ called GoJQ, most of your JQ knowledge is transferable with only slight changes/additions. This is probably the most used transform so there’s a little short cut to make using it a bit easier:\ntransform:  jq:  query: .descriptionThe query supports Templating.\nSince version 0.5.0 an optional yaml_input boolean can be set true to allow YAML input to be processed using JQ.\nTo JSON Transform The to_json transform can convert YAML or JSON format input into JSON format output. By default the output JSON will be compact unindented JSON, prefix and indent strings can be configured.\n# unindented JSON output transform:  to_json: {}# Indented JSON output with a custom prefix transform:  to_json:  indent: \" \"  prefix: \" \"To YAML Transform The to_yaml transform can convert JSON format input into YAML format output.\ntransform:  to_yaml: {}The to_yaml transform has no options.\nBar Graph Transform This transform takes a JSON document like {\"x\": 1, \"y\": 2} as input and renders bars for the values.\nHere is an example that draws the sizes of the assets of the latest release:\nname: bargraph description: Draws an ASCII bar graph type: exec transform:  pipeline:  - jq:  query: | .assets|map({(.name): .size})|reduce .[] as $a ({}; . + $a)   - bar_graph:  caption: \"Release asset sizes\"  bytes: true script: | curl -s https://api.github.com/repos/choria-io/appbuilder/releases/latestThis uses a pipeline (see below) to transform a GitHub API request into a hash and then a bar_graph to render it:\n$ demo bargraph Latest release asset sizes appbuilder-0.1.1-windows-arm64.zip: ▏ (2.0 MiB) appbuilder-0.1.1-arm64.rpm: ██ (2.0 MiB) appbuilder-0.1.1-linux-arm64.tar.gz: ███ (2.0 MiB) appbuilder-0.1.1-arm64.deb: ███ (2.0 MiB) appbuilder-0.1.1-windows-arm7.zip: █████████████ (2.1 MiB) appbuilder-0.1.1-windows-arm6.zip: ██████████████ (2.1 MiB) appbuilder-0.1.1-arm7.rpm: ██████████████ (2.1 MiB) appbuilder-0.1.1-arm7.deb: ███████████████ (2.1 MiB) appbuilder-0.1.1-linux-arm7.tar.gz: ███████████████ (2.1 MiB) appbuilder-0.1.1-arm6.rpm: ███████████████ (2.1 MiB) appbuilder-0.1.1-arm6.deb: ███████████████ (2.1 MiB) appbuilder-0.1.1-linux-arm6.tar.gz: ███████████████ (2.1 MiB) appbuilder-0.1.1-windows-amd64.zip: ███████████████████████ (2.2 MiB) appbuilder-0.1.1-darwin-arm64.tar.gz: █████████████████████████ (2.2 MiB) appbuilder-0.1.1-x86_64.rpm: ███████████████████████████ (2.2 MiB) appbuilder-0.1.1-linux-amd64.tar.gz: ███████████████████████████ (2.2 MiB) appbuilder-0.1.1-amd64.deb: ███████████████████████████ (2.2 MiB) appbuilder-0.1.1-darwin-amd64.tar.gz: ████████████████████████████████████████ (2.3 MiB)The transform supports a few options, all are optional:\n   Option Description     width The width of the bar, defaults to 40   caption The cpation to show above the graph, supports Templating   bytes When set to true indicates that the numbers rendered after the bars will be bytes like in the example    Line Graph This transform takes input of floats per line or a JSON document (array of floats) and turns it into a line graph.\nHere we find the hourly forecast for our location and graph it:\ndescription: Hourly weather forecast type: exec transform:  pipeline:  - jq:  query: | .weather[0].hourly|.[]|.FeelsLikeC  - line_graph:  width: 40  height: 10  caption: Hourly weather forecast (C) command: | curl -s wttr.in/?format=j1When run this produces:\n$ demo linegraph 30.00 ┤ ╭─────╮ 29.90 ┤ ╭╯ │ 29.80 ┤ ╭╯ ╰╮ 29.70 ┤ │ │ 29.60 ┤ ╭╯ ╰╮ 29.50 ┤ │ │ 29.40 ┤ ╭╯ ╰╮ 29.30 ┤ │ ╰╮ 29.20 ┤ ╭╯ │ 29.10 ┤ ╭╯ ╰╮ 29.00 ┼────────────────╯ ╰───── Hourly weather forecast (C)The transform supports a few options, all are optional:\n   Option Description     width The width of the graph, defaults to 40   height The height of the graph, defaults to 20   precision The decimal precision to consider and render   json When true expects JSON input like [1,2,3,4] rather than a float per line   caption The caption to show above the graph, supports Templating    Templates The template transform uses Golang templates and the sprig functions to facilitate creation of text output using a template language.\nname: template type: exec description: Demonstrates template processing of JSON input command: | echo '{\"name\": \"James\", \"surname\":\"Bond\"}' transform:  template:  contents: | Hello {{ .Input.name }} {{ .Input.surname | swapcase }}   Option Description     contents The body of the template embedded in the application yaml file   source The file name holding the template, the file name is parsed using Templating    Writing to a file Data entering a the write_file transform is written to disk and also returned, but optionally a message can be returned.\nname: template type: exec description: Demonstrates template processing of JSON input command: | echo '{\"name\": \"James\", \"surname\":\"Bond\"}' transform:  pipeline:  - write_file:  file: /tmp/name.txt  replace: true   - template:  contents: | Hello {{ .Input.name }} {{ .Input.surname | swapcase }}Above the /tmp/name.txt would hold the initial JSON data.\nIf the write_file is the only transform or in a pipeline like here the data received is simply passed on to the next step, this can be annoying when writing large files as they will be dumped to the screen.\ntransform:  - write_file:  file: /tmp/report.txt  replace: true  message: Wrote {{.IBytes}} to {{.Target}}In this case the message Wrote 1.8 KiB to /tmp/report.txt would be printed. You can use .Bytes, .IBytes, .Target and .Contents in the message.\n   Option Description     file The file to write, the file name is parsed using Templating   message A message to emit from the transform instead of the contents received by it   replace Set to true to always overwrite the file    Row orientated Reports These reports allow you to produce text reports for data found in JSON files. It reports on Array data and produce paginated reports with optional headers and footers.\nname: report type: exec description: Demonstrates using a report writer transform command: curl -s https://api.github.com/repos/choria-io/appbuilder/releases/latest transform:  report:  name: Asset Report  initial_query: assets  header: |+@||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| data.name --------------------------------------------------------------------------------   body: |Name: @\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c Size: @B###### Downloads: @## row.name, row.size, row.download_count  footer: |+2   ====================  Total Downloads: @##  report.summary.download_countHere we fetch the latest release information from GitHub and produce a report with header, footer and body. Since the JSON data from GitHub is a object we use the assets GJSON query to find the rows of data to report on.\nSee the goform project for a full reference to the formatting language.\nRelease 0.2.1 -------------------------------------------------------------------------------- Name: appbuilder-0.2.1-amd64.deb Size: 2.3 MiB Downloads: 2 Name: appbuilder-0.2.1-arm6.deb Size: 2.2 MiB Downloads: 0 Name: appbuilder-0.2.1-arm6.rpm Size: 2.1 MiB Downloads: 0 .... Name: appbuilder-0.2.1-windows-arm7.zip Size: 2.1 MiB Downloads: 0 Name: appbuilder-0.2.1-x86_64.rpm Size: 2.2 MiB Downloads: 2 ==================== Total Downloads: 20    Option Description     name The name of the report, parsed using Templating   header The report header   body The report body   footer The report footer   rows_per_page How many rows to print per page, pages each have header and footer   initial_query The initial GJSON query to use to find the row orientated data to report   source_file A file holding the report rather than inline, name, header, body and footer are read from here. File name parsed using Templating    Scaffold The scaffold transform takes JSON data and can generate multiple files using that output.\nThis is essentially the Scaffold Command in transform form, we suggest you read the Command documentation for full details on the underlying feature. Here we’ll just cover what makes the transform unique.\n Version Hint This was added in version 0.9.0\n     Option Description     target The directory to write the data into   post Post processing directives   skip_empty Skips files that would be empty when written   left_delimiter Custom template delimiter   right_delimiter Custom template delimiter    These settings all correspond to the same ones in the command so we won’t cover them in full detail here.\nThe scaffold transform returns the input JSON on its output.\nPipelines We’ve seen a few example transform pipelines above, like this one here:\ntype: exec transform:  pipeline:  - jq:  query: | .weather[0].hourly|.[]|.FeelsLikeC  - line_graph:  width: 80  caption: Hourly weather forecast (C) command: | curl -s wttr.in/?format=j1This runs the output of the curl command (JSON weather forecast data) through a jq transform that produce results like:\n29 29 29 29 30 30 29 29We then feed that data into a line_graph and render it, the output from the jq transform is used as input to the line_graph.\nAny failure in the pipeline will terminate processing.\n","description":"","tags":null,"title":"Transformations","uri":"/reference/transformations/index.html"},{"content":"To support supplying items like passwords, tokens, custom applications or paths we support loading a per-application configuration file.\nThis file is stored in example-cfg.yaml in the standard file locations.\nIt’s any valid YAML file, for example:\n# /etc/appbuilder/demo-cfg.yaml Cowsay: animalsayThis can then we used in templates. If a configuration item is required I suggest always using it with the require function:\ncommand: | slack-notify --token \"{{.Config.slack.token | require \"slack token not set\" }}\"","description":"","tags":null,"title":"Configuration","uri":"/reference/configuration/index.html"},{"content":"While output from --help can be useful, many people just don’t read it or understand the particular format and syntax shown. Instead, a quick cheat sheet style help can often be more helpful.\nThere is a great utility called cheat that solves this problem in a generic manner, by allowing searching, indexing and rendering of cheat sheets in your terminal.\n$ cheat tar # To extract an uncompressed archive: tar -xvf /path/to/foo.tar # To extract a .tar in specified Directory: tar -xvf /path/to/foo.tar -C /path/to/destination/We like this format and want to make it available to your App Builder apps, since 0.0.7 it is possible to add cheat sheets to your application, access them without needing to install the cheat command but also integrate them with that command if you choose.\nCheats are grouped by label, so while your application might have natsctl report jetstream the cheats are only 1 level deep and does not need to match the names of commands.\nExample Let’s see an example, we’ll update the example from the quick start to have cheats:\nname: demo description: Demo application for Choria App Builder author: https://github.com/choria-io/appbuilder  cheat:  tags:  - mycorp  - cows  label: demo # this would be the default if not given  cheat: |# To say something using a cow demo say hello # To think something using a cow demo think hello  commands:  - name: say  description: Say something using the configured command  type: exec  cheat:  cheat: |# This command can be configured using the Cowsay configuration Cowsay: /usr/bin/animalsay  command: | {{ default .Config.Cowsay \"cowsay\" }} {{ .Arguments.message | escape }}  arguments:  - name: message  description: The message to send to the terminal  required: trueWhen we run it we see:\nusage: demo [\u003cflags\u003e] \u003ccommand\u003e [\u003cargs\u003e ...] Demo application for Choria App Builder Contact: https://github.com/choria-io/appbuilder Use 'demo cheat' to access cheat sheet style help Commands: say \u003cmessage\u003e ....Since we added 2 cheats just running demo cheat will show a list:\n$ demo cheat Available Cheats: demo sayAnd we can access the cheat sheet directly:\n$ demo cheat demo # To say something using a cow demo say hello # To think something using a cow demo think helloIntegrate with cheat The cheat is great, and I really suggest you check it out, if you have it installed you can export all the cheats from your builder app into it:\n$ demo cheat --save /home/rip/.config/cheat/cheatsheets/personal/demo Saved cheat to /home/rip/.config/cheat/cheatsheets/personal/demo/demo Saved cheat to /home/rip/.config/cheat/cheatsheets/personal/demo/sayWith this done you can simply do cheat demo/say, or find all the cheats tagged mycorp which is one of the tags we added to ours:\n$ cheat -l -t mycorp title: file: tags: demo/demo /home/rip/.config/cheat/cheatsheets/personal/demo/demo cows,mycorp,personal demo/say /home/rip/.config/cheat/cheatsheets/personal/demo/say cows,mycorp,personal","description":"","tags":null,"title":"Cheat Sheets","uri":"/reference/cheats/index.html"},{"content":"","description":"","tags":null,"title":"Categories","uri":"/categories/index.html"},{"content":"The only configuration you should be concerned about is your Application Definition and optional Application Configuration.\nWe support the XDG Base specification, including standard environment variable based overrides like using XDG_CONFIG_HOME, for storing these in your home directory and have system wide fallback locations.\nFiles are stored in either /etc/appbuilder/ or ~/.config/appbuilder (~/Library/Application Support/appbuilder on a Mac). When the symlink is created to a choria binary the locations /etc/choria/builder and ~/.config/choria/builder (~/Library/Application Support/choria/builder on a Mac) will also be searched in addition to the standard locations.\n   File Description     demo-app.yaml This is your application definition   demo-cfg.yaml This is your per-application configuration    ","description":"","tags":null,"title":"File Locations","uri":"/reference/file-locations/index.html"},{"content":"When just invoking appbuilder various utilities are exposed, your apps also take some Environment Variables as runtime configuration.\nBuilder Info General runtime information can be printed:\n$ appbuilder info Choria Application Builder Debug Logging (BUILDER_DEBUG): false Configuration File (BUILDER_CONFIG): not specified Definition File (BUILDER_APP): not specified Source Locations: /home/example/.config/appbuilder, /etc/appbuilderHere we can see where applications are loaded from and more.\nRun Time Configuration As seen above a few variables are consulted, below a list with details:\n   Variable Description     BUILDER_DEBUG When set to any level debug logging will be shown to screen   BUILDER_CONFIG When invoking a command a custom configuration file can be loaded by setting the path in this variable   BUILDER_APP When invoking a command a custom application definition can be loaded by setting the path in this variable    With these variables set the appbuilder info command will update accordingly\nFinding Commands All applications stored in source locations can be listed:\n$ appbuilder list ╭─────────────────────────────────────────────────────────────────────────────────────────╮ │ Known Applications │ ├────────┬──────────────────────────────────────────────┬─────────────────────────────────┤ │ Name │ Location │ Description │ ├────────┼──────────────────────────────────────────────┼─────────────────────────────────┤ │ mycorp │ /home/rip/.config/appbuilder/mycorp-app.yaml │ A hello world sample Choria App │ ╰────────┴──────────────────────────────────────────────┴─────────────────────────────────╯Validating Definitions A recursive deep validate can be run across the entire definition which will highlight multiple errors in commands and sub commands:\n$ appbuilder validate mycorp-app.yaml Application definition mycorp-app.yaml not valid: root -\u003e demo (parent): parent requires sub commands root -\u003e demo (parent) -\u003e echo (exec): a command is required","description":"","tags":null,"title":"Runtime Settings and Tools","uri":"/reference/running-validation/index.html"},{"content":"","description":"","tags":null,"title":"Tags","uri":"/tags/index.html"}]
[{"content":"Command Types As we saw above we have parent and exec types of commands. Users can add more but these are the core ones we support today.\nMost commands are made up of a generic set of options and then have one or more added in addition to specialise them.\nCommon properties reference Most commands include a standard set of fields - those that do not or have special restritions will mention in the docs.\nLets look at how we can produce this command:\nusage: demo say [\u003cflags\u003e] \u003cmessage\u003e Says something using the cowsay command The command called defaults to cowsay but can be configured using the Cowsay configuration item Flags: --help Show context-sensitive help (also try --help-long and --help-man). --cowfile=FILE Use a specific cow file Args: \u003cmessage\u003e The message to display It’s made up of a commands member that has these properties:\nname: example description: Example application version: 1.0.0 author: Operations team \u003cops@example.net\u003e help_template: default # optional  commands:  -  # The name in the command: 'example say ....' (required)  name: say   # Help showng in output of 'example help say' or 'example say --help` (required)  description: |Says something using the cowsay command The command called defaults to cowsay but can be configured using the Cowsay configuration item   # Selects the kind of command, see below (required)  type: exec # or any other known type   # Optionally you can run 'example say hello' or 'example s hello' (optional)  aliases:  - s    # Arguments to accept (optional)  arguments:  - name: message  description: The message to display  required: true   # Flags to accept (optional)  flags:  - name: cowfile  description: Use a specific cow file  placeholder: FILE   # Sub commands to create below this one (optional, but see specific references)  commands: [] Here we show the initial options that define the application followed by commands. All the top settings are required except help_template, it’s value may be one of compact, long or default. When not set it will equal default. Experiment with these options to see which help format suits your app best (requires version 0.0.9).\nSince version 0.0.4 if a specific flag or argument has a finite number of options, you can limit it using the enum option and we have a default option to complement it, here’s an example:\nflags:  - name: eyes  description: Control the eyes of the cow  enum: [\"*\", \"+\", \"x\", \"@\"]  default: \"+\" If any option other than those are supplied an error will be raised. If --eyes is not given it will default to +.\nSince version 0.0.6 you can emit a banner before invoking the commands in an exec, use this to show a warning or extra information to users before running a command. Perhaps to warn them that a config override is in use like here:\n - name: say  description: Say something using the configured command  type: exec  command: | {{ default .Config.Cowsay \"cowsay\" }} {{ .Arguments.message | escape }}  banner: |{{- if (default .Config.Cowsay \"\") -}} \u003e\u003e \u003e\u003e Using the {{ .Config.Cowsay }} command \u003e\u003e {{- end -}}  arguments:  - name: message  description: The message to send to the terminal  required: true Since version 0.0.7 we support Cheat Sheet style help, see the dedicated guide about that.\n","description":"","tags":null,"title":"Common Settings","uri":"/reference/common-settings/"},{"content":"Installation Over on our Releases page you will find binaries, rpms, debs, zip files and more holding the appbuilder command. There is just one command and you can place it anywhere in your path.\nIf your editor supports it there is a JSON Schema for the definition.\nWe publish OS X and Linux homebrew packages:\n$ brew tap choria-io/tap $ brew install choria-io/tap/appbuilder Hello World We will make a little command that invokes cowsay to demonstrate some of the capabilities of the system.\nWe want to be able to run this command and it should invoke cowsay, cowthink or if configured to do so use animalsay instead of cowsay\n$ demo say \"hello world\" $ demo think \"hello world\" First we have to write a YAML file that describes our demo application, we have reference sections in the wiki for all the options, so this being an introduction, will be short on details.\nname: demo description: Demo application for Choria App Builder author: https://github.com/choria-io/appbuilder commands: - name: say description: Say something using the configured command type: exec command: | {{ default .Config.Cowsay \"cowsay\" }} {{ .Arguments.message | escape }} arguments: - name: message description: The message to send to the terminal required: true - name: think description: Think something using a cow type: exec command: | cowthink {{ .Arguments.message | escape }} arguments: - name: message description: The message to send to the terminal required: true Place this file in either /etc/appbuilder/demo-app.yaml or ~/.config/appbuilder/demo-app.yaml (~/Library/Application Support/appbuilder/demo-app.yaml on a Mac).\n$ sudo mkdir -p /etc/appbuilder/demo-app.yaml $ sudo ln -s /usr/local/bin/appbuilder /usr/bin/demo $ demo say \"hello world\" _____________ \u003c hello world \u003e ------------- \\ ^__^ \\ (oo)\\_______ (__)\\ )\\/\\ ||----w | || || $ demo think \"this is pretty cool\" _____________________ ( this is pretty cool ) --------------------- o ^__^ o (oo)\\_______ (__)\\ )\\/\\ ||----w | || || Finally, if you read the YAML file, you may see we made the system configurable, lets look how that works.\nCreate the following in /etc/appbuilder/demo-cfg.yaml\nCowsay: animalsay Now when we invoke demo say it will use animalsay:\n$ demo say \"hello world\" _____________ \u003c hello world \u003e ------------- \\ ____________ \\ |__________| / /\\ / / \\ /___________/___/| | | | | ==\\ /== | | | O O | \\ \\ | | \u003c | \\ \\| /| | \\ \\ / | \\_____/ | / / / /| | / /| /||\\| | /||\\/ -------------| | | | | \u003c__/ \\__\u003e ","description":"","tags":null,"title":"Quick Start","uri":"/quick-start/"},{"content":"While output from --help can be useful, many people just don’t read it or understand the particular format and syntax shown. Instead, a quick cheat sheet style help can often be more helpful.\nThere is a great utility called cheat that solves this problem in a generic manner, by allowing searching, indexing and rendering of cheat sheets in your terminal.\n$ cheat tar # To extract an uncompressed archive: tar -xvf /path/to/foo.tar # To extract a .tar in specified Directory: tar -xvf /path/to/foo.tar -C /path/to/destination/ We like this format and want to make it available to your App Builder apps, since 0.0.7 it is possible to add cheat sheets to your application, access them without needing to install the cheat command but also integrate them with that command if you choose.\nCheats are grouped by label, so while your application might have natsctl report jetstream the cheats are only 1 level deep and does not need to match the names of commands.\nExample Let’s see an example, we’ll update the example from the quick start to have cheats:\nname: demo description: Demo application for Choria App Builder author: https://github.com/choria-io/appbuilder  cheat:  tags:  - mycorp  - cows  label: demo # this would be the default if not given  cheat: |# To say something using a cow demo say hello # To think something using a cow demo think hello  commands:  - name: say  description: Say something using the configured command  type: exec  cheat:  cheat: |# This command can be configured using the Cowsay configuration Cowsay: /usr/bin/animalsay  command: | {{ default .Config.Cowsay \"cowsay\" }} {{ .Arguments.message | escape }}  arguments:  - name: message  description: The message to send to the terminal  required: true When we run it we see:\nusage: demo [\u003cflags\u003e] \u003ccommand\u003e [\u003cargs\u003e ...] Demo application for Choria App Builder Contact: https://github.com/choria-io/appbuilder Use 'demo cheat' to access cheat sheet style help Commands: say \u003cmessage\u003e .... Since we added 2 cheats just running demo cheat will show a list:\n$ demo cheat Available Cheats: demo say And we can access the cheat sheet directly:\n$ demo cheat demo # To say something using a cow demo say hello # To think something using a cow demo think hello Integrate with cheat The cheat is great, and I really suggest you check it out, if you have it installed you can export all the cheats from your builder app into it:\n$ demo cheat --save /home/rip/.config/cheat/cheatsheets/personal/demo Saved cheat to /home/rip/.config/cheat/cheatsheets/personal/demo/demo Saved cheat to /home/rip/.config/cheat/cheatsheets/personal/demo/say With this done you can simply do cheat demo/say, or find all the cheats tagged mycorp which is one of the tags we added to ours:\n$ cheat -l -t mycorp title: file: tags: demo/demo /home/rip/.config/cheat/cheatsheets/personal/demo/demo cows,mycorp,personal demo/say /home/rip/.config/cheat/cheatsheets/personal/demo/say cows,mycorp,personal ","description":"","tags":null,"title":"Cheat Sheets","uri":"/reference/cheats/"},{"content":"A parent is a placeholder, you can have a command like example deploy status and example deploy upgrade, here the deploy is a parent. It’s just there to group related commands and takes no action on it’s own.\nIt requires the the name, description, type and commands and the optional aliases.\nIt does not accept flags, arguments or confirm_prompt.\nname: deploy description: Manage deployment of the system type: parent  # Commands are required for the parent type and should have more than 1 commands: [] ","description":"","tags":null,"title":"Parent Command Type","uri":"/reference/parent/"},{"content":"Use the exec command to execute commands found in your shell, and, optionally format their output through JQ.\nRunning commands An exec runs a command, it is identical to the generic example shown earlier and accepts flags, arguments and sub commands. The only difference is that it adds a command, environment (since 0.0.3) and transform (since 0.0.5) items.\nBelow the example that runs cowsay integrated with configuration:\nname: say description: Says something using the cowsay command type: exec  environment:  - \"MESSAGE={{ .Arguments.message}}\"  command: | {{ default .Config.Cowsay \"cowsay\" }} \"{{ .Arguments.message | escape }}\"  arguments:  - name: message  description: The message to display  required: true The command is how the shell command is specified and we show some templating. This will read the .Config hash for a value Cowsay if it does not exist it will default to \"cowsay\". We also see how we can reference the .Arguments to access the value supplied by the user, we escape it for shell safety.\nWe also show how to set environment variables using environment, this too will be templated.\nSince version 0.0.9 setting environment variable BUILDER_DRY_RUN to any value will enable debug logging, log the command and terminate without calling your command.\nShell scripts A shell script can be added directly to your app, setting shell will use that command to run the script, if not set it will use $SHELL, /bin/bash or /bin/sh which ever is found first.\n Version Hint Added in version 0.0.8\n  The script is parsed through templating.\nname: script description: A shell script type: exec shell: /bin/zsh script: |for i in {1..5} do echo \"hello world\" done Transformation using JQ If you have a command that is known to emit JSON data you can ask appbuilder to transform that data using a dialect of JQ called GoJQ, the resulting data will be printed to STDOUT.\n Version Hint Added in version 0.0.5\n  name: ghd description: Gets the description of a Github Repo type: exec command: |curl -H \"Accept: application/vnd.github.v3+json\" https://api.github.com/repos/{{ .Arguments.owner }}/{{ .Arguments.repo }}  transform:  query: .description  arguments:  - name: owner  description: The repo owner  required: true   - name: repo  description: The repo name  require: true Here we fetch data from the GitHub API and use the internal JQ to transform it by extracting just the one item.\n$ demo ghd choria-io appbuilder Tool to create friendly wrapping command lines over operations tools ","description":"","tags":null,"title":"Exec Command Type","uri":"/reference/exec/"},{"content":"Command Components The system primarily is there to execute a type of command somewhere in the hierarchy of a CLI tools sub commands.\nLets say we have an app called demo that has commands demo say and demo think the say and think bits are commands. In this example these are commands of type exec - they run a shell command.\nIf we had a command demo deploy status and demo deploy upgrade then generally the deploy would not perform any action, it’s there mainly to achor sub commands and show help information. Here the deploy command would be of type parent.\nGenerally I would suggest nested commands are structured as root -\u003e parent -\u003e parent -\u003e exec and never root -\u003e parent -\u003e exec -\u003e exec. If you do decide to do that I strongly suggest the first exec is a read only action like showing some status. User should feel safe to execute parents without unintended side effects.\nFlags and Arguments Often we need to pass some parameters to commands, for example if we have one to upgrade some software it might be demo upgrade 1.2.3. Here the 1.2.3 is an argument, you can have a number of arguments and they can be set to be required or optional. If you have multiple arguments an optional one can not be before a required one.\nFlags are generally kept for optional items like demo upgrade 1.2.3 --channel=nightly, here we pass a flag --channel. At present we only support flags with string values. We intend to support enums of valid values and boolean flags.\n","description":"","tags":null,"title":"Reference","uri":"/reference/"},{"content":"The KV command interact with the Choria Key-Value Store and supports usual operations such as Get, Put, Delete and more.\nSince this is built into Choria it will simply use your Choria Client configuration for the user executing the command to find the Choria Brokers and more. It supports the usual override methods such as creating a choria.conf file in your project working directory. No connection properties are required or supported.\n Version Hint This feature is only available when hosting App Builder applications within the Choria Server version 0.26.0 or newer\n  Overview All variations of this command have a number of required properties, here’s the basic get operation, all these keys are required:\nname: version description: Retrieve the `version` key type: kv  action: get bucket: DEPLOYMENT key: version Usual standard properties like flags, arguments, commands and so forth are all supported. The bucket and key flags supports templating.\nWriting data using put Data can be written to the bucket, it’s identical to the above example with the addition of the value property that supports templating.\nname: version description: Stores a new version for the deployment type: kv  action: put bucket: DEPLOYMENT key: version value: '{{- .Arguments.version -}}' arguments:  - name: version  description: The version to store  required: true Retrieving data and transformations using get Stored data can be retrieved and rendered to the screen, typically the value is just dumped. Keys and Values however have additional metadata that can be rendered in JSON format.\nname: version description: Retrieve the `version` key type: kv  action: get bucket: DEPLOYMENT key: state  # Triggers rendering the KV entry as JSON that will include metadata ab out the value. json: true Further if it’s known that the entry holds JSON data it can be formatted using GOJQ:\nname: version description: Retrieve the `version` key type: kv  action: get bucket: DEPLOYMENT key: state  transform:  query: .state Deleting data using del Deleting a specific key is very similar to a basic retrieve, just use a different action:\nname: version description: Deletes the deployment configuration property type: kv  action: del bucket: DEPLOYMENT key: configuration Viewing key history using history Choria Key-Value store optionally has historical data for keys, the data can be shown in tabular (default) or JSON formats:\nname: version description: Deploy version history type: kv  action: history bucket: DEPLOYMENT key: version  # optionally renders the result as JSON json: true ","description":"","tags":null,"title":"KV Command Type","uri":"/reference/kv/"},{"content":"The Discover command interact with the Choria Discovery system used to find fleet nodes based on a vast array of possible queries and data sources.\nSince this is built into Choria it will simply use your Choria Client configuration for the user executing the command to find the Choria Brokers and more. It supports the usual override methods such as creating a choria.conf file in your project working directory. No connection properties are required or supported.\nBefore using this command type I suggest reading about the Choria Discovery System.\n Version Hint This feature is only available when hosting App Builder applications within the Choria Server version 0.26.0 or newer\n  Overview This command supports all the standard properties like Arguments, Flags, Banners and more, below is a simply command that finds apache servers.\nname: find description: Finds all machines tagged as Apache Servers type: discover  std_filters: true filter:  classes:  - roles::apache When run it will show a list of matching nodes, one per line. It also accepts the --json flag to enable returning a JSON array of matching nodes.\nSince the std_filters option is set the command will also accept additional filters in standard Choria format. Flags like -C, -F, discovery mode selectors and more. User supplied options will be merged/appended with the ones supplied in the YAML file. By default, none of the standard Choria flags will be added to the CLI.\nAll the filter values, even arrays and objects, support templating.\nFilter Reference The main tunable here is the filter, below a reference of available options. The examples here are a bit short, I suggest you read the Choria Discovery Documentation for a thorough understanding.\n   Key Description Example     collective The collective to target, defaults to main collective collective: development   facts List of fact filters as passed to -F facts: [\"country=uk\"]   agents List of agent filters as passed to -A agents: [\"puppet\"]   classes List of Config Management classes to match as passed to -C classes: [\"apache\"]   identities List of node identities to match as passed to -I identities:[\"/^web/\"]   combined List of Combined filters as passed to -W combined:[\"/^web/\",\"location=uk\"]   compound A single Compound filter as passed to -S compound: \"with('apache') or with('nginx')   discovery_method A discovery method to use like inventory as passed to --dm discovery_method:\"flatfile\"   discovery_options A set of discovery options, specific to the discovery_method chosen discovery_options: {\"file\":\"/etc/inventory.yaml\"}   discovery_timeout How long discovery can run, in seconds, as passed to --discovery-timeout discovery_timeout: 2   dynamic_discovery_timeout Enables windowed dynamic timeout rather than a set discovery timeout dynamic_discovery_timeout: true   nodes_file Short cut to use flatfile discovery with a specific file, as passed to --nodes nodes_file: /etc/fleet.txt    ","description":"","tags":null,"title":"Discover Command Type","uri":"/reference/discovery/"},{"content":"The RPC command interact with the Choria RPC system used execute actions on remote nodes.\nSince this is built into Choria it will simply use your Choria Client configuration for the user executing the command to find the Choria Brokers and more. It supports the usual override methods such as creating a choria.conf file in your project working directory. No connection properties are required or supported.\nBefore using this command type I suggest reading about Choria Concepts.\n Version Hint This feature is only available when hosting App Builder applications within the Choria Server version 0.26.0 or newer\n  Overview This command supports all the standard properties like Arguments, Flags, Banners and more, it also incorporates the discovery features of the Discover Command Type in order to address nodes.\nBelow a simple RPC request.\nname: stop description: Stops the Service gracefully type: rpc  request:  agent: service  action: stop  inputs:  service: httpd This will look and behave exactly like choria req service stop service=httpd.\nAdjusting CLI Behavior A number of settings exist to adjust the behavior or add flags to the CLI at runtime. Generally you can either allow users to supply values sugh as --json, or force the output to be JSON but you cannot allow both at present:\n   Setting Description     std_filters Enables standard filter flags like -C, -W and more   output_format Forces a specific output format, one of senders, json or table   output_format_flags Enables --senders, --json and --table options, cannot be set with output_format   display Supplies a setting to the typical --display option, one of ok, failed, all or none   display_flag Enables the --display flag on the CLI, cannot be used with display   batch_flags Adds the --batch and --batch-sleep flags   batch, batch_sleep Supplies values for --batch and --batch-sleep, cannot be used with batch_flags   no_progress Disables the progress bar`   all_nodes_confirm_prompt A confirmation prompt shown when an empty filter is used    Request Parameters Every RPC request needs request specified that must have at least agent and action set.\nInputs are allowed as a string hash - equivalent to how one would type inputs on the choria req CLI.\nIt also accepts a filter option that is the same as that in the discover command.\nname: stop description: Stops the Service gracefully type: rpc  request:  agent: service  action: stop  inputs:  service: httpd  filter:  classes:  - roles::apache Filtering Replies Results can be filtered using a result filter, this allows you to exclude/include specific replies before rendering the results.\nHere’s an example that will find all Choria Servers with a few flags to match versions, it invokes the rpcutil#daemon_states action and then filters results matching a query. Only the matching node names are shown.\nname: busy description: Find Choria Agents matching certain versions type: rpc  # list only the names output_format: senders  flags:  - name: ne  description: Finds nodes with version not equal to the given  placeholder: VERSION  reply_filter: ok() \u0026\u0026 semver(data(\"version\", \"!= {{.Flags.ne}}\"))  - name: eq  description: Finds nodes with version equal to the given  placeholder: VERSION  reply_filter: ok() \u0026\u0026 semver(data(\"version\", \"== {{.Flags.eq}}\"))  request:  agent: rpcutil  action: daemon_stats Transforming Results Results can be transformed using GOJQ syntax, here’s one that gets the state of a particular autonomous agent:\nname: state description: Obtain the state of the service operator type: rpc transform:  query: | .replies | .[] | select(.statuscode==0) | .sender + \": \" + .data.state request:  agent: choria_util  action: machine_state  inputs:  name: nats When run it will just show lines like:\nn1-lon: RUN n3-lon: RUN n2-lon: RUN ","description":"","tags":null,"title":"Choria RPC Command Type","uri":"/reference/rpc/"},{"content":"To support supplying items like passwords, tokens, custom applications or paths we support loading a per-application configuration file.\nThis file is stored in example-cfg.yaml in the standard file locations.\nIt’s any valid YAML file, for example:\n# /etc/appbuilder/demo-cfg.yaml Cowsay: animalsay This can then we used in templates. If a configuration item is required I suggest always using it with the require function:\ncommand: | slack-notify --token \"{{.Config.slack.token | require \"slack token not set\" }}\" ","description":"","tags":null,"title":"Configuration","uri":"/reference/configuration/"},{"content":"Templates allow you to interpolate values from Flags, Arguments and Configuration into some aspects of commands.\nFor example the exec command type allows you to use templates to put arguments into the command being run.\nWe use the Go template language at the moment, it’s not the best we might look at something else later.\nOnly some fields are parsed through templates, the documentation for each command type will call out what is supported.\nReference An example template use was shown in the exec documentation:\ncommand: | {{ default .Config.Cowsay \"cowsay\" }} \"{{ .Arguments.message | escape }}\" Here we have examples of accessing the .Config and .Arguments structures and using some functions.\nAvailable Data    Key Description     .Config Data stored in the configuration file for this application   .Arguments Data supplied by users using command arguments   .Flags Data supplied by users using command flags    Available Functions    Function Description Example     require Asserts that some data is available, errors with an optional custom message on failure {{ .Config.Password | require \"Password not set in the configuration\" }}   escape Escapes a string for use in shell arguments {{ .Arguments.message | escape }}   read_file Reads a file {{ read_file .Arguments.file }}   default Checks a value, if its not supplied uses a default {{ default .Config.Cowsay \"cowsay\" }}    ","description":"","tags":null,"title":"Templating","uri":"/reference/templating/"},{"content":"","description":"","tags":null,"title":"Categories","uri":"/categories/"},{"content":"The only configuration you should be concerned about is your Application Definition and optional Application Configuration.\nWe support the XDG Base specification, including standard environment variable based overrides like using XDG_CONFIG_HOME, for storing these in your home directory and have system wide fallback locations.\nFiles are stored in either /etc/appbuilder/ or ~/.config/appbuilder (~/Library/Application Support/appbuilder on a Mac). When the symlink is created to a choria binary the locations /etc/choria/builder and ~/.config/choria/builder (~/Library/Application Support/choria/builder on a Mac) will also be searched in addition to the standard locations.\n   File Description     demo-app.yaml This is your application definition   demo-cfg.yaml This is your per-application configuration    ","description":"","tags":null,"title":"File Locations","uri":"/reference/file-locations/"},{"content":"When just invoking appbuilder various utilities are exposed, your apps also take some Environment Variables as runtime configuration.\nBuilder Info General runtime information can be printed:\n$ appbuilder info Choria Application Builder Debug Logging (BUILDER_DEBUG): false Configuration File (BUILDER_CONFIG): not specified Definition File (BUILDER_APP): not specified Source Locations: /home/example/.config/appbuilder, /etc/appbuilder Here we can see where applications are loaded from and more.\nRun Time Configuration As seen above a few variables are consulted, below a list with details:\n   Variable Description     BUILDER_DEBUG When set to any level debug logging will be shown to screen   BUILDER_CONFIG When invoking a command a custom configuration file can be loaded by setting the path in this variable   BUILDER_APP When invoking a command a custom application definition can be loaded by setting the path in this variable    With these variables set the appbuilder info command will update accordingly\nFinding Commands All applications stored in source locations can be listed:\n$ appbuilder list ╭─────────────────────────────────────────────────────────────────────────────────────────╮ │ Known Applications │ ├────────┬──────────────────────────────────────────────┬─────────────────────────────────┤ │ Name │ Location │ Description │ ├────────┼──────────────────────────────────────────────┼─────────────────────────────────┤ │ mycorp │ /home/rip/.config/appbuilder/mycorp-app.yaml │ A hello world sample Choria App │ ╰────────┴──────────────────────────────────────────────┴─────────────────────────────────╯ Validating Definitions A recursive deep validate can be run across the entire definition which will highlight multiple errors in commands and sub commands:\n$ appbuilder validate mycorp-app.yaml Application definition mycorp-app.yaml not valid: root -\u003e demo (parent): parent requires sub commands root -\u003e demo (parent) -\u003e echo (exec): a command is required ","description":"","tags":null,"title":"Runtime Settings and Tools","uri":"/reference/running-validation/"},{"content":"","description":"","tags":null,"title":"Tags","uri":"/tags/"}]